二叉排序树又称为二叉查找树
递归定义：二叉排序树可以是空树，或具有如下性质：
1、若它的左子树非空，则左子树上所有的结点的值均小于根节点的值；
2、若它的右子树非空，则右子树上所有结点的值均大于或者等于根结点的值。
3、它的左右子树也分别为二叉排序/查找树
二叉排序树的存储结点为二叉树，使用二叉链表作为存储结构
！！二叉排序树的插入与创建
（1）二叉排序树的插入
算法思想：
1>.若二叉树是空树，则key成为二叉排序树的根。
2>.若二叉排序树非空，则将key与二叉排序树的跟进行比较：
    如果key的值等于根节点的值，则停止插入
    如果key的值小于根结点的值，则将key插入左子树
    如果key的值大于根结点的值，则将key插入到右子树
 
 二叉排序树的定义
 typedef struct node{
    int key;//关键字的值
    struct node *lchild,*rchild;
 }BSTNode,*BSTree;
 
 二叉排序树插入的递归算法
 void InsertBST(BSTree *bst,int key){
    BSTree s;
    if(*bst==NULL){//递归结束条件,空树，将key作为它的根
        s=(BSTree)malloc(sizeof(BSTNode)); //申请新的节点
        s->key=key;
        s->lchild=NULL;
        s->rchild=NULL;
        *bst=s;
    }
    else if(key<(*bst)->key)){ //将s插入到左子树
        InsertBST(&((*bst)->lchild),key);
    }
    else if(key>(*bst)->key)
        InsertBST(&((*bst)-rchild),key);
 }
 二叉排序树的插入算法的时间复杂度为O（log2n）。
 
 （2）二叉排序树的创建
算法思想：
先将二叉排序树初始化为一棵空树，然后逐个读入元素，每读一个元素创立一个新的结点，并插入到当前已经生成的二叉排序树中，即通过多次调用插入新节点的算法实现。注意：插入时比较结点顺序始终是从二叉树的根结点开始。
创建二叉排序树
void createBST(BSTree *bst){//从键盘输入元素的值，创建相应的二叉排序树
        int key;
        *bst=NULL;
        scanf("%d",&key);
        while(key!=ENDKEY){
                InsetBST(bst,key);
                scanf("%d",&key);
        
        }
}
假设有n个元素则需要插入n次，创建二叉排序树的时间复杂度为O(nlog2n)。













